name: PR Tests

on:
  pull_request:
    branches:
      - main
  workflow_dispatch:

# Cancel previous runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # First, discover all PR test configs
  discover-configs:
    runs-on: [self-hosted, entropy]
    outputs:
      configs: ${{ steps.find-configs.outputs.configs }}

    steps:
      - uses: actions/checkout@v4

      - name: Find PR test configs
        id: find-configs
        run: |
          # Find all yaml files in configs/pr_tests/ and output as JSON array
          echo "Searching for configs in configs/pr_tests/..."
          ls -la configs/pr_tests/ || echo "Directory not found or empty"

          configs=$(ls configs/pr_tests/*.yaml 2>/dev/null | xargs -I {} basename {} .yaml | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "configs=$configs" >> $GITHUB_OUTPUT

          echo "=== Found PR test configs ==="
          echo "$configs" | jq -r '.[]'
          echo "Total: $(echo "$configs" | jq 'length') config(s)"

  # Run each config as a separate job
  run-pr-test:
    needs: discover-configs
    runs-on: [self-hosted, entropy]
    strategy:
      fail-fast: false
      matrix:
        config: ${{ fromJson(needs.discover-configs.outputs.configs) }}
    steps:
      - uses: actions/checkout@v4
      # 1) Submit SLURM job and expose job_id
      - name: Submit SLURM job - ${{ matrix.config }}
        id: submit
        run: |
          echo "=== Submitting PR test for config: ${{ matrix.config }} ==="
          chmod +x .github/scripts/run_remote_pr_check.sh

          # --parsable makes sbatch output just the job ID (or jobID;something)
          job_output=$(sbatch \
            --parsable \
            --job-name="pr_test_${{ matrix.config }}" \
            --output="slurm-%j.out" \
            --export=ALL \
            .github/scripts/run_remote_pr_check.sh)

          # Usually it's either "12345" or "12345;stuff"
          job_id="${job_output%%;*}"

          echo "Submitted job: $job_output"
          echo "Parsed job_id: $job_id"

          # Expose as step output
          echo "job_id=$job_id" >> "$GITHUB_OUTPUT"

      # 2) Wait for SLURM job to finish (polling)
      - name: Wait for SLURM job
        id: wait
        run: |
          job_id="${{ steps.submit.outputs.job_id }}"
          echo "Waiting for job $job_id to finish..."

          # Simple polling loop; you can tune sleep / commands as you like
          while true; do
            state=$(sacct -j "$job_id" --format=State --noheader | head -1 | awk '{print $1}')
            echo "Current state: $state"

            case "$state" in
              COMPLETED)
                echo "Job completed successfully."
                exit 0
                ;;
              FAILED|CANCELLED|TIMEOUT)
                echo "Job ended with state: $state"
                exit 1
                ;;
              ""|PENDING|RUNNING|CONFIGURING|SUSPENDED)
                sleep 10
                ;;
              *)
                echo "Unknown state: $state"
                sleep 10
                ;;
            esac
          done

      # 3) Cancel SLURM job if workflow is cancelled
      - name: Cancel SLURM job on workflow cancellation
        if: cancelled() && steps.submit.outputs.job_id
        run: |
          job_id="${{ steps.submit.outputs.job_id }}"
          echo "Workflow cancelled, cancelling SLURM job $job_id"
          scancel "$job_id" || echo "Failed to cancel SLURM job (may have already completed)"

      # 4) Always try to show SLURM output
      - name: Display SLURM output
        if: always()
        run: |
          latest_out=$(ls -t slurm-*.out 2>/dev/null | head -1)
          if [ -n "$latest_out" ]; then
            echo "=== SLURM Output for ${{ matrix.config }} ==="
            cat "$latest_out"
          else
            echo "No slurm-*.out files found."
          fi
